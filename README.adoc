= RSQL-QueryDSL 

Author : John Michael Vincent S. Rustia +


ifdef::env-github[]
image:https://api.travis-ci.org/vineey/archelix-rsql.svg?token%2FkdSmFoN3e8GGHqffx761["Build Status", link="https://travis-ci.org/vineey/archelix-rsql"]
image:http://img.shields.io/:license-mit-blue.svg["License", link="https://github.com/vineey/archelix-rsql/blob/master/LICENSE.md"]
image:https://coveralls.io/repos/github/vineey/archelix-rsql/badge.svg?branch=develop["Coverage Status", link="https://coveralls.io/github/vineey/archelix-rsql?branch=develop"]
image:https://api.codacy.com/project/badge/grade/b119ffa40c674a18850c31ec3878c044["Codacy code quality", link="https://www.codacy.com/app/vinetech416/archelix-rsql"]
image:https://maven-badges.herokuapp.com/maven-central/com.github.vineey/rsql-api-all/badge.svg["Maven Central", link="http://repo1.maven.org/maven2/com/github/vineey/rsql-api-all/"]
endif::env-github[]

_This library brings the convenience of SQL declarative nature to restful APIs in the form of RSQL
but without the danger of sql injection by using a typesafe mapping of allowed field paths defined
via integration with querydsl library. Like sql, it supports clauses such as select, filter, pagination 
and sorting that can easily be represented in http request parameters_.

_It primarily supports JPA model but if possible will strive to handle other kinds of database such as MongoDB.
This is a small project but at its heart is dedicated to maintain highly cohesive and modular components.
Contributions and suggestions are very much welcome and appreciated!_


== QueryDSL API Modules

Rql specification used by this library is defined by this https://github.com/persvr/rql[reference]. +
Please see for more information about rql expressions.

*  filter - uses https://github.com/jirutka/rsql-parser[rsql-parser] library ast to convert filter string into its querydsl predicate equivalent
*  select - converts rql select expression into its querydsl projection equivalent
*  page - converts rql limit expression into its querydsl pagination equivalent
*  sort - converts rql sort expression into its querydsl sorting equivalent
*  spring - provides integration with spring data such as pageable


== 1.0.0 Milestones

=== M1
Completes filter conversion to querydsl predicate.

=== M2
Completes sort and page conversion for rsql querydsl +

=== M3
Completes select conversion to querydsl projections. +
Full support on Mongodb select, filter, sort and page conversion. +
Technically, prior to 1.0.0.M3, api should work seamlessly with Querydsl Mongodb, but wasn't tested yet.

== 2.0.0 Milestones
*  Support for rsql conversion to https://github.com/jOOQ/jOOQ[JOOQ] Library
*  ?

== MAVEN

=== Bundled Rsql Querydsl Modules

You can get all rsql-querydsl modules via this dependency,

```xml
<dependency>
    <groupId>com.github.vineey</groupId>
    <artifactId>rsql-querydsl-all</artifactId>
    <version>1.0.0.M2</version>
</dependency>
```


[source,groovy]
[subs="attributes"]
----
dependencies {
    compile 'com.github.vineey:rsql-querydsl-all:1.0.0.M2'
  }
----

=== Selective Rsql Querydsl Modules

or you can specify which module you only need by changing the artifactId by any of the ff:

*  rsql-querydsl-filter
*  rsql-querydsl-sort
*  rsql-querydsl-page

such as
[source,groovy]
[subs="attributes"]
----
dependencies {
    compile 'com.github.vineey:rsql-querydsl-filter:1.0.0.M2'
  }
----

To integrate with Spring Data Pageable, include this dependency,

[source,groovy]
[subs="attributes"]
----
dependencies {
    compile 'com.github.vineey:rsql-querydsl-spring:1.0.0.M2'
  }
----

=== Querydsl Integration Dependencies Required

*  com.mysema.querydsl:querydsl-core:3.x.x or prior

=== Spring Integration Dependencies Required
*  org.springframework.data:spring-data-commons:1.x.x or prior


== API DOCS

=== Querydsl Filter (rsql-querydsl-filter)
Note: AOTM, this only supports first level fields of the entity or document. But will support embeddable pojo
and other kinds of nested querydsl path.

[source,java]
----

DefaultFilterParser filterParser = new DefaultFilterParser();

String rqlFilter = "employee.name == 'John'";

Map<String, Path> pathHashMap = ImmutableMap.<String, Path>builder()
                .put("employee.name", QEmployee.employee.name)
                .put("employee.age", QEmployee.employee.age)
                .put("employee.bday", QEmployee.employee.birthDate)
                .build();

Predicate predicate = filterParser.parse(rsqlFilter, withBuilderAndParam(new QuerydslFilterBuilder(), new QuerydslFilterParam()
                                                                             .setMapping(pathHashMap)));

  //or a shorter version
                                                                             
Predicate predicate = filterParser.parse(rsqlFilter, withMapping(pathHashMap));
                                                                             
----


=== Querydsl Sort Conversion (rsql-querydsl-sort)
Note: AOTM, this only supports first level fields of the entity or document. But will support embeddable pojo
and other kinds of nested querydsl path.

[source,java]
----
String sortExpression = "sort(+employeeNumber)";

DefaultSortParser sortParser = new DefaultSortParser();

Map<String, Path> mappings = ImmutableMap.<String, Path>builder()
        .put("employeeNumber", QEmployee.employee.employeeNumber)
        .build();

OrderSpecifierList orderSpecifierList = sortParser.parse(sortExpression, QuerydslSortContext.withMapping(mappings));

List<OrderSpecifier> orderSpecifiers = orderSpecifierList.getOrders();
----


=== Querydsl Page Conversion (rsql-querydsl-page)

[source,java]
----

String rqlPage = "limit(10, 5)";

DefaultPageParser defaultPageParser = new DefaultPageParser();

QueryModifiers querydslPage = defaultPageParser.parse(rqlPage, withDefault());

or a simplified version

QuerydslPageParser querydslPageParser = new QuerydslPageParser();

QueryModifiers querydslPage = querydslPageParser.parse(rqlPage);

----

=== Bundled All Querydsl Modules (rsql-querydsl-all)

[source,java]
----

String rqlFilter = "(employee.number=='1' and employee.names =size= 1)
  or (employee.number=='2'  and employee.names =size= 2)";

String limit = "limit(0, 10)";

String sort = "sort(+employee.number)";

RqlInput rqlInput = new RqlInput()
        .setFilter(rqlFilter)
        .setLimit(limit)
        .setSort(sort);

Map<String , Path> pathMapping = ImmutableMap.<String, Path>builder()
        .put("employee.number", QEmployee.employee.employeeNumber)
        .put("employee.names", QEmployee.employee.names)
        .build();

QuerydslRqlParser querydslRqlParser = new DefaultQuerydslRqlParser();

QuerydslMappingResult querydslMappingResult = querydslRqlParser.parse(rqlInput, new QuerydslMappingParam().setPathMapping(pathMapping));

Predicate predicate = querydslMappingResult.getPredicate();

QueryModifiers querydslPage = querydslMappingResult.getPage();

List<OrderSpecifier> orderSpecifiers = querydslMappingResult.getOrderSpecifiers();

----

=== Integration of Querydsl to Spring Data Pageable

[source,java]
----

Pageable pageable = SpringUtil.toPageable(orderSpecifiers, querydslPage);

----


You can now use Predicate, QueryModifiers, OrderSpecifier or Pageable +
in the Querydsl API, or in JPAQuery/MongoQuery of QEmployee, +
or in the Spring Data JPA/Mongo Repository.

=== A MORE APPROPRIATE WIKI
To be follow!!!